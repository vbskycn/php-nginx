# 技术文档

## 概述

本项目基于 Alpine Linux 构建的轻量级 PHP-FPM 8.4 & Nginx 1.26 容器镜像，集成了 Redis 缓存服务。

## 技术栈

- **基础镜像**: Alpine Linux 3.21
- **Web服务器**: Nginx 1.26
- **PHP运行时**: PHP 8.4-FPM
- **缓存服务**: Redis
- **进程管理**: Supervisord

## 架构特点

### 安全设计
- 使用非特权用户（nobody）运行所有服务
- 隐藏服务器标识头信息
- 禁用危险的Redis命令
- 文件权限严格控制

### 性能优化
- PHP-FPM使用`ondemand`进程管理器，按需创建进程
- 针对512MB VPS优化的内存配置
- 启用OPcache加速
- Gzip压缩支持
- 静态资源缓存策略

## 配置说明

### Nginx配置
- 监听8080端口（容器内）
- 支持PHP文件处理
- 静态资源5天缓存
- 健康检查端点（/fpm-ping, /fpm-status）
- 安全防护（拒绝访问隐藏文件）

### PHP-FPM配置
- Unix socket通信（/run/php-fpm.sock）
- 最大50个并发进程
- 10秒空闲超时
- 1000请求后重启进程（防止内存泄漏）

### Redis配置
- 无持久化存储（适合缓存场景）
- 64MB内存限制
- LRU淘汰策略
- 仅本地访问

## 扩展功能

### 添加 Composer 支持

如果您的项目中需要 [Composer](https://getcomposer.org/)，这里有一个简单的方法来添加它。

```Dockerfile
FROM vbskycn/php-nginx:latest

# 从官方镜像安装 composer
COPY --from=composer /usr/bin/composer /usr/bin/composer

# 运行 composer install 来安装依赖项
RUN composer install --optimize-autoloader --no-interaction --no-progress
```

#### 使用 Composer 构建

如果您正在构建一个包含源代码和由 composer 管理的依赖项的镜像，那么定义可以改进。

```Dockerfile
FROM composer AS composer

# 复制源代码目录并使用 composer 安装依赖项
COPY <your_directory>/ /app

# 运行 composer install 来安装依赖项
RUN composer install \
  --optimize-autoloader \
  --no-interaction \
  --no-progress

# 继续使用所需镜像进行阶段构建，并复制源代码，包括由 composer 下载的依赖项
FROM vbskycn/php-nginx:latest
COPY --chown=nobody --from=composer /app /var/www/html
```

### 添加 Xdebug 支持

创建以下文件 `xdebug.ini`

```ini
zend_extension=xdebug.so
xdebug.mode=develop,debug
xdebug.discover_client_host=true
xdebug.start_with_request=yes
xdebug.trigger_value=PHPSTORM
xdebug.log_level=0

xdebug.var_display_max_children=10
xdebug.var_display_max_data=10
xdebug.var_display_max_depth=10

xdebug.client_host=host.docker.internal
xdebug.client_port=9003
```

使用以下 `Dockerfile` 创建新镜像

```Dockerfile
FROM vbskycn/php-nginx:latest

# 临时切换到 root 用户
USER root

# 安装 xdebug
RUN apk add --no-cache php84-pecl-xdebug

# 添加配置
COPY xdebug.ini ${PHP_INI_DIR}/conf.d/xdebug.ini

# 切换回非 root 用户
USER nobody
```

### 添加 HTTPS/SSL 支持

> 以下所有说明应根据您的个人需求进行调整

如果您计划仅在本地工作，首先生成您的自签名证书和密钥：

```bash
openssl req -x509 -nodes -newkey rsa:2048 -keyout https.key -out https.crt -subj "/CN=localhost" -days 5000
```

然后在Dockerfile的构建阶段复制您的证书文件：

```Dockerfile
FROM vbskycn/php-nginx:latest

# ...

COPY https.crt /etc/nginx/ssl/default.crt
COPY https.key /etc/nginx/ssl/default.key

# ...

```

编辑您的 nginx.conf 文件。

```nginx
server {
    listen [::]:443 ssl;
    listen 443 ssl;
    server_name localhost;
    root /var/www/html/public;

    ssl_certificate /etc/nginx/ssl/default.crt;
    ssl_certificate_key /etc/nginx/ssl/default.key;

    # ... 其余配置在这里
}
```

如果您使用 docker-compose，这里有一个示例：

```yaml
  php-nginx:
    build: ./api
    networks: [ backend ]
    ports: [ "443:443" ]
    working_dir: /var/www/html
    volumes:
      - ./api:/var/www/html
      - ./api/nginx.conf:/etc/nginx/conf.d/default.conf
    restart: on-failure
```

### 获取负载均衡器后客户端的真实IP

如果您在代理或负载均衡器后面使用此容器，您可能希望获取客户端的真实IP而不是代理或负载均衡器的IP。

为此，您可以将以下配置添加到 [Nginx 配置](../config/nginx.conf)：

```nginx
set_real_ip_from <CIDR>

real_ip_header X-Forwarded-For;
real_ip_recursive on;
```

其中 `<CIDR>` 是您的代理或负载均衡器的CIDR，请参阅 [Nginx 文档](http://nginx.org/en/docs/http/ngx_http_realip_module.html#set_real_ip_from)。客户端的真实IP现在将在PHP中的 `$_SERVER['REMOTE_ADDR']` 下可用。

### 发送邮件

要能够在PHP中使用 `mail()` 函数，您需要在容器中安装MTA（邮件传输代理）。

最简单的方法是安装 `ssmtp`。

`ssmtp.conf` 文件需要基于[在线文档](https://wiki.archlinux.org/title/SSMTP)创建。

```Dockerfile
FROM vbskycn/php-nginx:latest

# 安装 ssmtp
RUN apk add --no-cache ssmtp

# 添加配置
COPY ssmtp.conf /etc/ssmtp/ssmtp.conf
```

## 性能调优

### 内存优化
- PHP内存限制：64MB
- OPcache内存：32MB
- Redis内存限制：64MB

### 并发优化
- PHP-FPM最大进程数：50
- Nginx工作连接数：1024
- 支持100个并发用户

### 缓存策略
- 静态资源缓存：5天
- OPcache启用
- Redis LRU淘汰策略

## 监控和日志

### 健康检查
- 端点：`/fpm-ping`
- 状态：`/fpm-status`
- 超时：10秒

### 日志输出
- 所有服务日志重定向到容器输出
- 可通过 `docker logs -f <容器名称>` 查看
- 支持结构化日志格式

## 故障排除

### 常见问题

1. **容器无法启动**
   - 检查端口是否被占用
   - 验证配置文件语法

2. **PHP文件无法执行**
   - 检查文件权限
   - 验证PHP-FPM配置

3. **静态文件无法访问**
   - 检查Nginx配置
   - 验证文件路径

### 调试方法

```bash
# 查看容器日志
docker logs <容器名称>

# 进入容器调试
docker exec -it <容器名称> sh

# 检查服务状态
docker exec <容器名称> supervisorctl status
```
